# 构造函数、析构函数、拷贝构造函数
git：https://github.com/weichangk/hellocpp/tree/master/class

## 构造函数概述
构造函数是一种特殊的成员函数，用于创建对象时初始化对象的数据成员。在C++中，构造函数的名称与类名相同，没有返回类型，可以有参数。当创建对象时，构造函数会自动调用，以初始化对象的数据成员。

构造函数有以下特点：
- 构造函数的名称与类名相同，没有返回类型，可以有参数。
- 构造函数可以有多个重载版本，根据参数的不同进行区分。
- 构造函数可以被继承，但不能被继承的构造函数包括拷贝构造函数和移动构造函数。
- 如果没有定义构造函数，编译器会自动生成一个默认构造函数，用于初始化对象的数据成员。
- 如果存在构造函数重载，编译器不再提供默认构造函数，如果还要使用默认构造函数进行初始化时需要显示提供。
- 构造函数可以使用初始化列表来初始化对象的数据成员，也可以在函数体内进行初始化。
- 构造函数可以被声明为虚函数，但通常不建议这样做。

## 析构函数概述
在C++中，析构函数是一种特殊的成员函数，用于在对象被销毁时释放对象所占用的资源。析构函数的名称与类名相同，但在名称前面加上一个波浪号（~）。

析构函数有以下特点：
- 析构函数的名称与类名相同，但在名称前面加上一个波浪号（~）。
- 析构函数没有参数，也没有返回值。
- 析构函数会在对象被销毁时自动调用，用于释放对象所占用的资源。
- 如果没有定义析构函数，编译器会自动生成一个默认析构函数，用于释放对象所占用的资源。
- 一般情况下空的析构函数就足够了，如果类中有指针成员，类必须写析构函数并释放指针成员所指向的空间。
- 析构函数可以被继承，但通常不建议这样做。

构造函数、析构函数定义，下面是一个简单的构造函数、析构函数示例：
```
class Person {
public:
  Person() {
    age = 0;
    name = "";
  }
  Person(int a, string n) {
    age = a;
    name = n;
  }
  ~Person() {
    cout << "Person object is destroyed." << endl;
  }
private:
  int age;
  string name;
};
```
在上面的示例中，Person类有两个构造函数，一个是默认构造函数，另一个是带参数的构造函数。默认构造函数用于初始化age和name成员变量，而带参数的构造函数用于在创建对象时初始化age和name成员变量。

Person类有一个析构函数，用于在对象被销毁时输出一条消息。当对象被销毁时，析构函数会自动调用，输出一条消息。另外，如果需要在析构函数中释放对象所占用的资源，可以在析构函数中进行相应的操作。例如，如果对象中包含动态分配的内存，可以在析构函数中释放该内存。


构造函数、析构函数使用
```
int main()
{
  Person p1;                  //隐式调用默认无参构造函数（推荐）
  Person p2 = Person();       //显示调用默认无参构造函数
  Person p3(0, "");           //隐式调用有参构造函数（推荐）
  Person p4 = Person(0, "");  //显示调用有参构造函数

  //匿名对象，执行完就释放，不会等到作用域结束才释放
  Person();  
  Person(0, "");  

  //构造函数 隐式转换（类中只有一个数据成员）
  //Person p5 = 100;
}
```

## 拷贝构造函数
拷贝构造函数本质是构造函数
在用旧对象初始化新对象的时候调用了拷贝构造
如果用户不提供拷贝构造，编译器默认提供拷贝构造（浅拷贝）
如果有指针成员，在用旧对象初始化新对象的使用情况下，不自定义拷贝构造函数实现深拷贝会有问题

拷贝构造和无参构造有参构造的关系
- 如果用户定义了拷贝构造或有参构造都会屏蔽默认的无参构造
- 如果用户定义了无参构造或有参构造不会屏蔽拷贝构造

拷贝构造几种调用形式
- 旧对象给新对象初始化
- 对象做为函数参数调用函数时
- 函数返回对象时（在vs中，返回值触发拷贝构造，将对象拷贝到匿名对象，如果没有引用接匿名对象就会直接释放，和编译器有关！）


系统默认的拷贝构造是可以完成浅拷贝（默认值赋值），一旦自定义实现了拷贝构造函数，必须完成成员的赋值操作（如果不赋值，将随机赋值），因为系统默认的拷贝构造函数无效了。
一般为了完成深拷贝才会去自定义实现拷贝构造函数。

```
//拷贝构造函数实现深拷贝
Person::Person(const Person& p)
{
  age = p.age;
  name = p.name;
  lastName = new char[strlen(p.lastName) + 1];
  strcpy(lastName, p.lastName);
  cout << lastName << " cpy ctor." << endl;
}
```
## 浅拷贝和深拷贝
默认的拷贝构造都是浅拷贝
如果类中没有指针成员，不用实现拷贝构造和析构函数
如果类中有指针成员，且指向堆区空间，必须实现析构函数释放指针成员指向的堆区空间，必须实现拷贝构造完成深拷贝



