# 静态成员
git：https://github.com/weichangk/hellocpp/tree/master/class

静态成员是指在类中被声明为静态的成员变量或成员函数。静态成员与类的实例无关，它们属于整个类，而不是类的某个实例。静态成员可以被所有类的实例共享，也可以通过类名直接访问。

静态成员变量可以用于记录类的某些属性，如类的实例数量等。静态成员函数可以用于实现与类相关的全局函数，如工厂函数等。

静态成员变量的声明方式为在变量名前加上关键字static，静态成员函数的声明方式为在函数名前加上关键字static。静态成员变量必须在类外进行定义和初始化，而静态成员函数可以在类内或类外进行定义和实现。

静态成员的访问方式有两种：通过类名访问和通过对象名访问。通过类名访问静态成员时，需要使用作用域解析运算符::，如ClassName::staticMember。通过对象名访问静态成员时，也可以使用作用域解析运算符，但建议使用类名访问，以强调静态成员的类级别属性。

## 静态成员变量
静态成员变量必须在类外进行定义和初始化，可以在类外定义时同时进行初始化，也可以在类外分别进行定义和初始化。

例如，定义一个类A，其中有一个静态成员变量count记录类的实例数量：
```
class A {
public:
  A() {
    count++;
  }
  static int count; // 静态成员变量声明
};

int A::count = 0; // 静态成员变量定义和初始化

int main() {
  A a1, a2, a3;
  cout << A::count << endl; // 3
  return 0;
}
```
在类外定义静态成员变量时，需要在变量名前加上类名和作用域解析运算符::，并在定义时进行初始化。在上面的例子中，静态成员变量count的定义和初始化语句为：
```
int A::count = 0;
```
这表示定义了一个名为count的静态成员变量，它属于类A，初始值为0。

在类中声明静态成员变量只是告诉编译器这个变量是属于类的，但并没有为它分配内存空间。因此，静态成员变量必须在类外进行定义和初始化，才能真正分配内存空间并赋初值。

## 静态成员函数
C++中的静态成员函数是指在类中被声明为静态的成员函数。静态成员函数与类的实例无关，它们属于整个类，而不是类的某个实例。静态成员函数可以被所有类的实例共享，也可以通过类名直接访问。

静态成员函数可以用于实现与类相关的全局函数，如工厂函数等。静态成员函数只能访问静态成员变量和其他静态成员函数，不能访问非静态成员变量和非静态成员函数。这是因为静态成员函数不属于任何类的实例，只能访问属于整个类的静态成员。

静态成员函数可以在类内或类外进行定义和实现，这意味着我们可以在类定义中声明静态成员函数，然后在类外定义和实现它们，也可以在类定义中同时声明和实现静态成员函数。

在类内定义静态成员函数的语法为：
```
class A {
public:
  static void func() {
    // 静态成员函数的实现
  }
};
```

在类内定义静态成员函数时，可以直接在类定义中实现它们，不需要在类外再进行定义和实现。

在类外定义静态成员函数的语法为：
```
class A {
public:
  static void func(); // 静态成员函数声明
};

void A::func() {
  // 静态成员函数的实现
}
```

静态成员函数在类中声明，在类外实现的作用主要有以下几点：
- 分离接口和实现：将静态成员函数的声明和实现分离到不同的文件中，可以使代码更加清晰和易于维护。这样，用户只需要包含声明文件即可使用静态成员函数，而不需要关心实现细节。
- 减少编译时间：如果将静态成员函数的实现放在头文件中，每次包含头文件时都会重新编译实现代码，导致编译时间变长。将静态成员函数的实现放在源文件中，可以避免这个问题，减少编译时间。
- 隐藏实现细节：将静态成员函数的实现放在源文件中，可以隐藏实现细节，防止用户直接访问实现代码，从而提高代码的安全性。
- 方便代码重用：将静态成员函数的实现放在源文件中，可以方便地在不同的项目中重用代码，提高代码的可重用性。
- 总之，将静态成员函数的声明和实现分离到不同的文件中，可以提高代码的可维护性、可重用性和安全性，同时也可以减少编译时间。


## 单例模式
单例模式是一种常用的设计模式，它保证一个类只有一个实例，并提供一个全局访问点。在C++中，可以通过静态成员变量和静态成员函数来实现单例模式。

下面是一个使用静态成员变量和静态成员函数实现单例模式的例子：
```
namespace ns_class_07
{
  class Singleton {
  private:
    static Singleton* instance; // 静态成员变量声明，用于保存唯一实例的指针
    Singleton() {} // 构造函数私有化，防止外部创建实例
  public:
    static Singleton* getInstance() { // 静态成员函数，用于获取唯一实例的指针
      if (instance == nullptr) { // 如果实例不存在，则创建一个新实例
        instance = new Singleton();
      }
      return instance;
    }
  };

  Singleton* Singleton::instance = nullptr; // 静态成员变量初始化为nullptr
}
```

静态成员变量必须在类外进行定义和初始化，所以私有静态成员变量可以在类外部进行访问和初始化，但是不能直接被修改。这是因为私有静态成员变量仍然受到访问控制的限制，只能在类的成员函数中进行修改。