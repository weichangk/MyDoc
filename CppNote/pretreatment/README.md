# pretreatment 预处理

## 内存分配
在C++程序中，内存被划分为以下几个区域：
1. 栈区（stack）： 存储函数的局部变量、参数的值、返回值以及函数调用的上下文等信息。由编译器自动分配和释放内存。栈是一种"后进先出"的结构，所以后定义的变量先被销毁。

2. 堆区（heap）： 通常用于动态分配内存，也称为自由存储区。需要手动分配和释放内存。通常使用 new 和 delete 操作符来分配和释放内存。

3. 全局/静态区（global/static）： 存储全局变量和静态变量，在程序生命周期内一直存在。

4. 常量区（constant）： 存储字符串常量和其他类型的不可修改的数据。

5. 代码区：代码的二进制指令。

至于具体的代码、数据等存储在哪些区域，则取决于它们的类型、作用域等特征。比如：
1. 函数内部的局部变量通常存储在栈区；
2. 全局变量和静态变量通常存储在全局区；
3. const修饰的全局变量和字符串常量通常存储在常量存储区；

在程序运行期间，各个存储区域的大小可以根据需要进行动态调整。需要注意优化代码时，合理地利用栈区和堆区的存储空间，避免因为占用大量内存而导致程序崩溃或者性能下降。

## 变量存储
### 普通局部变量
定义形式：在{}里面定义的普通变量叫普通局部变量
```
void func()
{//{}复合语句
  int num = 10;//num 局部变量
  {
    int num = 20;
    cout << num << endl;//20
    int data = 0;//data 局部变量
  }
  cout << num << endl;//10
}
```
作用范围：所在的{}复合语句之间有效
生命周期：所在的{}复合语句之间有效，执行到离开大括号普通局部变量就被自动回收
存储区域：栈区
注意：
1. 普通局部局部变量不初始化内容将不确定
2. 普通局部变量同名就近原则

### 普通全局变量
定义形式：在函数外定义的普通变量
```
//01_func.cpp
extern int data;//声明data为外部变量，来自其他源文件
int a = 10;//普通全局变量
void func()
{
  int a = 20;
  cout << ::a << endl;//10
  cout << data << endl;
}
void add_data()
{

}
```
```
//02_func.cpp
int data;
extern void add_data();
void func()
{
  int a = 20;
  cout << ::a << endl;//10
  add_data();
}
```
作用范围：当前源文件以及其他源文件都有效
生命周期：整个进程
存储区域：全局区
注意：
1. 全局变量不初始化内容将取变量类型默认值
2. 全局变量和局部变量同名优先选择局部变量，如果要在局部变量所在{}复合语句内访问同名全局变量需要通过作用域::访问
3. 要使用其他源文件的全局变量必须先对全局变量进行 extern 声明，在变量的使用所在的源文件用extern声明为外部变量，该变量或函数来自其他源文件。
### 静态局部变量
定义形式：在{}复合语句里面加static定义的局部变量叫做静态局部变量
```
void func()
{
  int a = 10;//普通局部变量
  static int b = 10;//静态局部变量
  b++;
  cout << a << b << endl;
}
int main()
{
  func();//10 11
  func();//10 12
  func();//10 13
}
```
作用范围：所在{}复合语句之间有效
生命周期：整个进程有效
存储区域：全局区
注意：
1. 静态局部变量不初始化内容将取变量类型默认值
2. 静态局部变量整个进程都存在（第一次定义有效）
### 静态全局变量
定义形式：在函数外加static修饰的变量就是静态全局变量
```
int a = 10;
static int b = 20;//静态全局变量
void func()
{

}
```
作用范围：只能在当前源文件使用，不能在其他文件使用
生命周期：整个进程
存储区域：全局区
注意：
1. 静态全局变量不初始化内容将取变量类型默认值
2. 静态全局变量只能在当前文件使用
## 全局函数和静态函数
全局函数：在当前文件以及其他源文件都可以使用，如果使用其他源文件函数需要extern对函数进行外部声明
静态函数：static修饰的函数只能在当前源文件使用
```
//section_01.h
#pragma once
int va = 1;
int getG(void);
```
```
//section_01.cpp
#include "section_01.h"
int getG(void)
{
  int va = 10;
  return va;
}
```
```
//section_02.h
#pragma once
static int va = 2;
static int getG(void);
int getO(void);
```
```
//section_02.cpp
#include "section_02.h"
static int getG(void)
{
  return va;
}
int getO(void)
{
  return getG();
}
```
```
#include "iostream"
// #include "section_01.h"
// #include "section_02.h"
using namespace std;

extern int va;
extern int getG(void);
extern int getO(void);

int main(int argc, char const *argv[])
{
  cout << "hello pretreatment" << endl;

  int a = getO();
  cout << a <<endl;//2
  int b = getG();
  cout << b <<endl;//10
  cout << va <<endl;//1
  cout << va*a*b <<endl;//1*2*10
}
```
## 头文件包含
"include" 是一个预处理器指令，用于将另一个文件的内容包括（或导入）到当前文件中。这通常用于包含头文件（.h）。头文件包含程序中要用到的类、函数、定义宏等。

它有两种形式：#include<filename>和#include"filename"。

\#include<filename>用于包含系统文件，编译器会按照系统规定路径查找文件。
而#include "filename"则用于包含用户自定义文件，编译器将首先在当前目录中查找该文件，如果找不到，则会按照系统规定路径查找文件。
因此，一般在项目开发中，包含自己的头文件使用 #include ""， 包含系统头文件使用 #include <>。


"extern"通常用于告诉编译器某些变量或函数名原本是定义在其他文件中，在当前文件中被使用，需要从其他文件中获取其定义的位置，这种机制被称为“外部链接”（external linkage），可以避免同一程序内出现同名变量的冲突问题。当然也可以直接在当前文件中定义并初始化之后再在其他文件中使用该变量。

"extern"和"include"有什么区别：
include 用于包含头文件并在程序中访问它们，而 extern 则用于在一个文件中声明另一个文件中定义的变量或函数。
## #define宏
编译四阶段：预处理、编译、汇编、连接

在C++中，#define是一个预处理器指令，用于定义常量、宏和条件编译。使用#define可以将一个标识符与一个表达式关联起来，并将其解释为该表达式的值。
\#undef可以解除#define。
使用#define定义的标识符是预处理指令，它并不会在内存中分配空间，因此不会存储在任何内存区域。 在编译时，预处理器将所有使用#define定义的标识符替换为预处理定义的文本，然后将源代码和替换过的文本发送给编译器进行编译和链接。因此，在程序运行时不会存在定义的标识符，而只有在预处理阶段应用的文本宏。

### 定义一个常量：
```
#define PI 3.14159
```
这将为标识符PI定义一个值为3.14159的常量。在编写程序时，可以使用PI代替3.14159。

### 定义一个宏：
```
#define SQUARE(X) ((X)*(X))
#define MY_MUL(a, b) a * b

MY_MUL(10, 20)//10 * 20
MY_MUL(10 + 10, 20 + 20)//10 + 10 * 20 + 20 = 230
```
这将定义一个名为SQUARE的宏，该宏将其参数平方并返回结果。例如，如果在代码中使用SQUARE(5)，则宏将被展开并计算为(5)*(5)，返回25。

宏的参数不能有类型，宏不能保证参数的完整性，可以使用()的形式让带参数的宏具有一定的完整性。

宏函数和普通函数的区别主要有以下几个方面：
1. 被处理时机不同
宏函数是在编译预处理阶段被处理，而普通函数是在程序运行时被处理。
2. 处理方式不同
宏函数是通过简单的文本替换来实现的，而普通函数是通过传递参数和调用栈等方式来实现的。
3. 处理结果不同
正常情况下，宏函数处理后直接替换为相应的文本，而普通函数则会执行一些代码并返回一个结果。
4. 使用限制不同
在宏函数中，可以使用其他定义过的宏或常量，但对于普通函数，需要在函数体内部进行初始化或者声明。此外，宏函数通常不能像普通函数那样使用返回值、指针等复杂数据类型，因为它们只是简单地扩展为代码文本。
5. 调用开销不同
由于宏函数是在编译期间直接展开的，所以相对于普通函数，在代码运行时会比较快。另一方面，由于展开后的宏函数可能会导致代码膨胀，因此也可能会增加可执行文件大小。

宏函数适合实现简单且不需要进行多级嵌套的函数，例如一系列的数学运算。它们可以被使用在那些需要高效执行但不需要太多安全性检查或者处理特殊情况的应用程序中。
总而言之，如果你决定使用宏函数，你必须意识到它存在的风险，并确保它们被用作预期和确定的目的。否则，最好使用普通函数代替它们。

### 条件编译：
```
#ifdef DEBUG
cout << "Debugging is on" << endl;
#endif
```
这将在代码中检查是否已定义一个名为DEBUG的宏。如果定义了DEBUG，则将输出“Debugging is on”。
需要注意的是，#define是在编译前执行的，因此无法将#define用于在运行时计算的值。